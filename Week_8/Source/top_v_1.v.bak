module top_v (
  input [9:0] A,
  input [9:0] B,
  input START,
  input EQUAL,
  input Addn_Sub,
  output wire [6:0] seg1,
  output reg [6:0] seg10,
  input CLK
  );
  /*
  reg r_start;
  always @ ( posedge START ) begin
    if(r_start == 1'b0) r_start <= 1'b1;
    else r_start <= 1'b0;
  end

  wire w_click;
  or(w_click, A[9],A[8],A[7],A[6],A[5],A[4],A[3],A[2],A[1],A[0]);
  wire [3:0] w_select;
  wire w_reset_counter;
  nand (w_reset_counter, w_select[0], 1'b1);
  ttl74163_v ttl74163_v(
    .PEn(PEn), // LDN Synchronous Load negative active
    .D(4'b0), // D, C, B, A
    .CET(1'b1), // ENT Count Enable Trickle
    .CEP(1'b1), // ENP Count Enable Parallel
    .MRn(w_reset_counter), // CLRN Synchronous Clear, negative active
    .CP(w_click), // CLK Rising Edge Trigger
    .Q(w_select), // QD, QC, QB, QA
    .TC() // RCO Ripple Carry out
    );*/

  /*
  wire w_start;
  wire w_equal;
  ttl7474_v ttl7474_v(
    .D1(START),
    .Q1(w_start),
    .Q1b(),
    .PR1n(1'b1),
    .CLR1n(1'b1),
    .CLK1(CLK),
    .D2(EQUAL),
    .Q2(w_equal),
    .Q2b(),
    .PR2n(1'b1),
    .CLR2n(1'b1),
    .CLK2(CLK)
    );
    */


  wire w_click_A;
  nand(w_click_A, A[9],A[8],A[7],A[6],A[5],A[4],A[3],A[2],A[1],A[0], 1'b1);
  wire w_click_B;
  nand(w_click_B, B[9],B[8],B[7],B[6],B[5],B[4],B[3],B[2],B[1],B[0], 1'b1);

  wire [5:0] w_A1n;
  wire [5:0] w_A2n;
  ttl74174_v ttl74174_A_1(
    .D({1'b0, A[4:0]}),
    .Q(w_A1n),
    .CLK(w_click_A),
    .CLRb(START)
    );

  ttl74174_v ttl74174_A_2(
    .D({1'b0, A[9:5]}),
    .Q(w_A2n),
    .CLK(w_click_A),
    .CLRb(START)
    );

  wire [5:0] w_B1n;
  wire [5:0] w_B2n;
  ttl74174_v ttl74174_B_1(
    .D({1'b0, B[4:0]}),
    .Q(w_B1n),
    .CLK(w_click_B),
    .CLRb(START)
    );

  ttl74174_v ttl74174_B_2(
    .D({1'b0, B[9:5]}),
    .Q(w_B2n),
    .CLK(w_click_B),
    .CLRb(START)
    );

  /*
  wire w_A_En;
  wire w_B_En;
  and (w_A_En, ~w_select[0], r_start);
  and (w_B_En, w_select[0], r_start);
  wire [9:0] w_A_select_n;
  wire [9:0] w_B_select_n;
  nand(w_A_select_n[0], A[0], w_A_En);
  nand(w_A_select_n[1], A[1], w_A_En);
  nand(w_A_select_n[2], A[2], w_A_En);
  nand(w_A_select_n[3], A[3], w_A_En);
  nand(w_A_select_n[4], A[4], w_A_En);
  nand(w_A_select_n[5], A[5], w_A_En);
  nand(w_A_select_n[6], A[6], w_A_En);
  nand(w_A_select_n[7], A[7], w_A_En);
  nand(w_A_select_n[8], A[8], w_A_En);
  nand(w_A_select_n[9], A[9], w_A_En);

  nand(w_B_select_n[0], A[0], w_B_En);
  nand(w_B_select_n[1], A[1], w_B_En);
  nand(w_B_select_n[2], A[2], w_B_En);
  nand(w_B_select_n[3], A[3], w_B_En);
  nand(w_B_select_n[4], A[4], w_B_En);
  nand(w_B_select_n[5], A[5], w_B_En);
  nand(w_B_select_n[6], A[6], w_B_En);
  nand(w_B_select_n[7], A[7], w_B_En);
  nand(w_B_select_n[8], A[8], w_B_En);
  nand(w_B_select_n[9], A[9], w_B_En);
  */
  /*
  reg [9:1] r_A;
  reg [9:1] r_B;
  reg r_Counter;
  always @ (A) begin
    if(r_start) begin
      if(r_Counter == 1'b0) begin
        if(A == 10'b0000000000) begin
          r_A <= r_A; //no change
          r_Counter <= 1'b0;
        end else if(A == 10'b0000000001) begin
          r_A <= 9'b111111111; //0
          r_Counter <= 1'b1;
        end else begin
          r_A <= ~A[9:1];
          r_Counter <= 1'b1;
        end
      end else begin
        if(A == 10'b0000000000) begin
          r_B <= r_B; //no change
          r_Counter <= 1'b1;
        end else if(A == 10'b0000000001) begin
          r_B <= 9'b111111111; //0
          r_Counter <= 1'b0;
        end else begin
          r_B <= ~A[9:1];
          r_Counter <= 1'b0;
        end
      end
    end else begin
      r_A <= 9'b111111111;
      r_B <= 9'b111111111;
      r_Counter <= 1'b0;
    end
  end
  */

  wire [3:0] w_A_BCD;
  wire [3:0] w_B_BCD;
  ttl74147_v ttl74147_v_A(
    .An({w_A2n[4:0], w_A1n[4:1]}),
    .Zn(w_A_BCD)
    );

  ttl74147_v ttl74147_v_B(
    .An({w_B2n[4:0], w_B1n[4:1]}),
    .Zn(w_B_BCD)
    );


  wire [3:0] w_A;
  wire [3:0] w_B;
  assign w_A = ~w_A_BCD;
  assign w_B = ~w_B_BCD;
  // Addn_Sub = 1'b0 <= add
  // Addn_Sub = 1'b1 <= sub
  wire [3:0] w_B_in;
  xor(w_B_in[0], Addn_Sub, w_B[0]);
  xor(w_B_in[1], Addn_Sub, w_B[1]);
  xor(w_B_in[2], Addn_Sub, w_B[2]);
  xor(w_B_in[3], Addn_Sub, w_B[3]);

  wire [3:0] w_S;
  wire w_Cout;
  ttl74283_v ttl74283_v(
    .A(w_A),
    .B(w_B_in),
    .Cin(Addn_Sub),
    .S(w_S),
    .Cout(w_Cout)
    );
  wire [4:0] result;
  wire w_msb;
  xor(w_msb, w_Cout, Addn_Sub);
  assign result = {w_msb, w_S};
  /*
  reg [3:0] r_seg1_decode_in;
  reg r_neg;
  reg r_seg10;
  always @ ( result ) begin
    if(result > 5'b01001) begin
      if(result > 5'b10110) begin
        r_neg <= 1'b1;
        r_seg10 <= 1'b0;
        r_seg1_decode_in <= (~result[3:0])+1'b1;
      end else begin
        r_neg <= 1'b0;
        r_seg10 <= 1'b1;
        if(result == 5'b01010) r_seg1_decode_in <= 4'b0000;
        if(result == 5'b01011) r_seg1_decode_in <= 4'b0001;
        if(result == 5'b01100) r_seg1_decode_in <= 4'b0010;
        if(result == 5'b01101) r_seg1_decode_in <= 4'b0011;
        if(result == 5'b01110) r_seg1_decode_in <= 4'b0100;
        if(result == 5'b01111) r_seg1_decode_in <= 4'b0101;
        if(result == 5'b10000) r_seg1_decode_in <= 4'b0110;
        if(result == 5'b10001) r_seg1_decode_in <= 4'b0111;
        if(result == 5'b10010) r_seg1_decode_in <= 4'b1000;
      end
    end else begin
      r_seg10 <= 1'b0;
      r_neg <= 1'b0;
      r_seg1_decode_in <= result;
    end
  end

  wire w_clk_en;
  and(w_clk_en, EQUAL, CLK);

  wire [5:0] w_seg_1_reg;
  wire [5:0] w_seg_10_reg;

  ttl74174_v ttl74174_v_1(
    .D({2'b0, r_seg1_decode_in[3:0]}),
    .Q(w_seg_1_reg),
    .CLK(w_clk_en),
    .CLRb(START)
    );

  ttl74174_v ttl74174_v_10(
    .D({4'b0, r_neg, r_seg10}),
    .Q(w_seg_10_reg),
    .CLK(w_clk_en),
    .CLRb(START)
    );

  seg_decoder_v seg_decoder_v_1(
    .i_A(w_seg_1_reg[3:0]),
    .o_Z(seg1)
    );

  always @ ( w_seg_10_reg ) begin
    if(w_seg_10_reg[1]) seg10 <= 7'b0000001;
    else if(w_seg_10_reg[0]) seg10 <= 7'b0110000;
    else seg10 <= 7'b1111110;
  end
  */
endmodule // top_v
